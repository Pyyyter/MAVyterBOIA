/*************************************************************************
 * This demo demonstrates how to display, configure and update a 
 * GLG realtime stripchart widget containing multiple individual charts
 * that share the same X axis. The charts are configured dynamically at 
 * run time based on the supplied configuration data that includes the 
 * list of variables to be plotted, as well as a chart title, a low/high 
 * range, a plot color and a data supply tag for each variable.
 *
 * The demo provides a floating dialog that allows the user to select the
 * variables to be plotted from a list defined by the configuration data.
 * When a variable is selected or deselected, its chart is added or removed
 * from the display, and the layout of all charts is automatically adjusted
 * to fill all available space using the new layout feature of the GLG square
 * series. The plot data for each variable are preserved even when the variable
 * is not displayed.
 *
 * The list of displayed variables can be changed on the fly by clicking on 
 * either Configuration1 or Configuration2 button. This reconfigures the 
 * charts according to the new configuration without reloading the drawing.
 *************************************************************************/

using System;
using System.Collections.Generic;
using System.Windows.Forms;
using System.IO;
using System.Timers;
using GenLogic;
using SimpleExample;

//////////////////////////////////////////////////////////////////////////
// Extend GlgControl class and create a custom GLG control with custom
// functionality.
//////////////////////////////////////////////////////////////////////////
public class GlgComboChart : GlgControl 
{
   /* RandomData is set to true to use simulated data for animation, 
      and false for live real-time data. In the demo, RandomData is assigned 
      by the parent container, using RANDOM_DATA flag or command 
      line option -random-data or live-data. 
   */
   public bool RandomData = true;

   // Disable warnings about unused ParentContainer.
#pragma warning disable 0414
   
   // Parent Form.
   FormChart ParentContainer;

   /* If set to true, datasource variable name (plot.tag_source) will be used 
      for data query. Otherwise, an integer representing datasource variable 
      index will be used, for example it could be an integer representing 
      sensor number.
   */
   public bool USE_DATAVAR_NAME = true;

   /* If set to true, the application supplies time stamp for each data 
      sample explicitly in DataFeed.GetPlotPoint(). Otherwise, time stamp 
      is automatically generated by the chart using current time.
   */
   public bool SUPPLY_TIME_STAMP = true;

   /* If this flag is set to true:
    - Data samples are pushed into each chart using low level API methods, 
      allowing to improve performance if needed.
    - AutoScale feature needs to be handled manually by the application,
      as opposed to having the chart handle it automatically;
    - SUPPLY_TIME_STAMP has to be set to true, so that the application
      supplies time stamp explicitly.
   */
   public bool FAST_DATA_PROCESSING = false;
   
   // DataFeed object is used to supply data for animation.
   ChartDataFeedInterface DataFeed;

   System.Timers.Timer timer = null;     /* Timer for periodic updates. */
   public int UpdateInterval = 100;      /* Update interval in msec. */

   // Flag to prevent a race condition when the timer is stopped.
   public bool TimerEnabled = false;

   // Top level viewport of the loaded drawing.
   GlgObject TopViewport;

   List<ChartConfigRecord> Configuration = null;

   // Stores information for individual chart.
   List<ChartInfo> ChartArray = null;

   /* Number of charts, gets intialized based on the configuration array 
      passed by the parent form to LoadDrawing().
   */
   public int NumCharts = 0;

   // Object ID of the Time axis.
   GlgObject TimeAxis;

   // Object ID of the Toolbar viewport.
   GlgObject Toolbar;

   /* Floating dialog allowing to toggle visibility of individual charts
      at runtime.
   */
   GlgObject ChartDialog;

   /* ChartMenu inside ChartDialog, used to control visibility of individual 
      charts. 
   */
   GlgObject ChartMenu;

   /*  Number of visible rows in the ChartMenu inside ChartDialog.
       If number of rows exceed this number, the menu will use a scrollbar.
   */
   int ChartMenuNumVisRows = 4;

   /* Flag to indicate the charts have been configured and ready for data 
      updates. It is set to true in SetChartConfiguration() and reset to false
      in ClearConfiguration().
   */
   bool Ready = false;

   /* Convenient time span constants. */
   const int TEN_SECONDS = 10;
   const int ONE_MINUTE = 60;
   const int ONE_HOUR = 3600;
   const int ONE_DAY = 3600 * 24;

   /* Initialize SpanData array used to handle the SpanSelector pulldown menu,
      which allows the user to change Span interval for the Time axis.
      The number of Time axis ticks, time format for the axis labels, etc. are
      adjusted as defined by the items in this array when the user selects 
      a menu item at runtime.

      SpanInfo item format:
           label_str, tim_span, major_interval, minor_interval, 
           time_format, tooltip_format.
     
      major_interval > 0 defines absolute interval in seconds;
      major_interval < 0 defines number of major ticks.
      Same applies to minor_interval.
   */
   SpanInfo[] SpanData = {
       new SpanInfo( "10 SEC", TEN_SECONDS,       1, 0.1, "%H:%M:%S",    null ),
       new SpanInfo( "30 SEC", 3 * TEN_SECONDS,   5, 0.5, "%H:%M:%S",    null ),
       new SpanInfo( "1 MIN",  ONE_MINUTE,       10,   1, "%H:%M:%S",    null ),
       new SpanInfo( "10 MIN", 10 * ONE_MINUTE,  60,  10, "%H:%M%n%n%x", null ),
       new SpanInfo( "30 MIN", 30 * ONE_MINUTE, -10,  -6, "%H:%M%n%x",   null ),
       new SpanInfo( "1 HOUR", ONE_HOUR,        -10, -10, "%H:%M%n%x",   null )
   };

   // Initial span index of the SpanSelector combobox widget (1min).
   const int INIT_SPAN_INDEX = 2;

   // Index of the currently displayed time span.
   int SpanIndex = INIT_SPAN_INDEX;

   int BufferSize = 50000;           /* Number of samples to keep in the buffer 
                                        for each line. */
   int TimeSpan;                     /* TimeAxis span in sec. */
   double ScrollIncrement;           /* Scroll increment in sec. */
   
   /* Time interval that defines the amount of data for prefilling the chart's 
      data history buffer on startup.
   */
   const int PREFILL_SPAN = ONE_HOUR;

   /* Constants for scrolling the chart to the beginning or the end of 
      the time range.
   */
   const int DONT_CHANGE = 0;
   const int MOST_RECENT = 1;     /* Make the most recent data visible. */
   const int LEAST_RECENT = 2;    /* Make the least recent data visible. */

   bool PrefillData = false;       /* Setting to False suppresses pre-filling 
                                        the  chart's buffer with data 
                                        on start-up. */
   int AutoScrollState = 1;          /* Current auto-scroll state: enabled (1) 
                                        or disabled (0). */
   int EnableYDragging = 1;          /* Current state of chart dragging in
                                        Y direction: enabled(1) or disabled (0).
                                        If disabled, chart dragging is 
                                        performed only in horizontal
                                        direction. */
   int StoredScrollState;            /* Stored AutoScrollState to be restored 
                                        if ZoomTo is aborted. */

   /* This flag is set to true when the user clicks on the ZoomTo button.
      ZoomTo mode is activated for the chart that the user selects with the 
      mouse click after clicking on the ZoomTo button.
    */
   bool StartZoomToMode = false;

   /* Stores current cursor position, used to calculate the time stamp
      at cursor and update the cross-hair line.
   */
   GlgPoint CursorPosition = null;

   // Store time stamp of the last update, as well as current time.
   public static double last_time = 0.0;
   public static double current_time = 0.0;
   
   /* Used in GetCurrTime(). Epoch_time is a DateTime object 
      representing Epoch time starting January 1, 1970 at 0:0:0,
      based on UTC.
   */
   static readonly DateTime Epoch_time =
     new DateTime( 1970, 1, 1, 0, 0, 0, DateTimeKind.Utc );
   
   /////////////////////////////////////////////////////////////////////
   // Constructor.
   /////////////////////////////////////////////////////////////////////
   public GlgComboChart( FormChart parent )
   {
      ParentContainer = parent;

      /* Activate Trace callback; by default, it is disabled. 
         In this example, it is used to activate chart scrolling 
         by dragging it with the mouse.
      */
      AddListener( GlgCallbackType.TRACE_CB, this );

      /* Disable automatic update for input events to avoid slowing down 
         real-time chart updates.
      */
      SetAutoUpdateOnInput( false );
   }

   /////////////////////////////////////////////////////////////////////
   // Add DataFeed object for supplying chart data.
   /////////////////////////////////////////////////////////////////////
   public void AddDataFeed()
   {
      if( RandomData )
      {
         DataFeed = new ChartDemoDataFeed( this );
         AppLog( "Using ChartDemoDataFeed." );
      }
      else
      {
         DataFeed = new ChartLiveDataFeed( this );
         AppLog( "Using ChartLiveDataFeed." );
      }
   }

   //////////////////////////////////////////////////////////////////////
   // Load a specified GLG drawing.
   //////////////////////////////////////////////////////////////////////
   public void LoadDrawing( string drawing_file )
   {
      if( drawing_file == null )
      {
         AppError( "Drawing loading failed.", false );
         return;
      }

      // Set DrawingFile property for the GlgControl.
      DrawingFile = drawing_file;
   }

   //////////////////////////////////////////////////////////////////////
   // Creates timer to perform periodic data updates.
   /////////////////////////////////////////////////////////////////////
   public void StartUpdates()
   {
      if( timer == null )
      {
         timer = new System.Timers.Timer();
         timer.AutoReset = false;
         timer.SynchronizingObject = this;
         timer.Interval = UpdateInterval;
         // Add timer event_cs handler.
         timer.Elapsed += new ElapsedEventHandler( OnTimerUpdate );
      }

      TimerEnabled = true;
      timer.Start();
   }

   ///////////////////////////////////////////////////////////////////////
   // StopUpdate() method stops periodic updates
   ///////////////////////////////////////////////////////////////////////
   public void StopUpdates()
   {
      if( timer != null )
      {
         timer.Stop();
         timer.Dispose();
         timer = null;
      }

      TimerEnabled = false;
   }

   ////////////////////////////////////////////////////////////////////////
   // HCallback is invoked after the Glg drawing is loaded, but before
   // the configure hierarchy setup takes place and before the drawing
   // is drawn for the first time. 
   ////////////////////////////////////////////////////////////////////////
   public override void HCallback( GlgObject viewport )
   {
      // Store top level viewport of the loaded drawing.
      TopViewport = viewport;

      // Remove the outline.
      TopViewport.SetDResource( "LineWidth", 0.0 );

      // Store object ID of the Toolbar containing various controls.
      Toolbar = viewport.GetResourceObject( "Toolbar" );

      InitChartDialog();

      // Store object ID of the Time axis.
      TimeAxis = viewport.GetResourceObject( "TimeAxis" );

      /* Enable automatic layout adjustment for the ChartSeries when
         individual charts change their visibility: if one of the charts
         becomes invisible, the height of the other charts is adjusted
         automatically to occupy the vacant space.
      */
      TopViewport.SetDResource( "ChartSeries/HandleInvisible",
                                (double) GlgHandleInvisible.SHIFT_ROWS );
      TopViewport.SetDResource( "ChartSeries/FillSpace",
                                (double) GlgFillSpace.ADJUST_ROW_HEIGHT );
   }

   ////////////////////////////////////////////////////////////////////////
   // VCallback() is invoked after the drawing is loaded and setup, 
   // but before it is drawn for the first time. 
   ////////////////////////////////////////////////////////////////////////
   public override void VCallback( GlgObject viewport )
   {
      /* Add DataFeed object used to supply chart data.
         The example uses demo data. To supply application specific
         data, replace ChartDemoDataFeed with a custom ChartLiveDataFeed.
      */
      AddDataFeed();
   }

   ////////////////////////////////////////////////////////////////////////
   public void InitChartDialog()
   {
      /* Store object ID of the ChartDialog viewport used to select variables
         to be plotted.
      */
      ChartDialog = TopViewport.GetResourceObject( "ChartDialog" );
      if( ChartDialog == null )
      {
         AppInfo( "ChartDialog not found." );
         return;
      }

      // Store object ID of the ChartMenu inside ChartDialog,
      ChartMenu = ChartDialog.GetResourceObject( "ChartMenu" );
      if( ChartMenu == null )
        AppInfo( "ChartMenu not found." );
      
      // Make it a floating dialog and set its title.
      ChartDialog.SetDResource( "ShellType",
                                (double) GlgShellType.DIALOG_SHELL );

      // Set dialog title. 
      ChartDialog.SetSResource( "ScreenName", "Chart Selection" );

      // Set dialog size and position.
      SetDialogSizeAndPosition( ChartDialog );      
      
      // Make the dialog visible on Start up.
      ShowChartDialog( true );
   }

   ////////////////////////////////////////////////////////////////////////
   // Chart initialization before hierarchy setup.
   // Set the number of stacked charts. The number of charts may be changed 
   // dynamically at run-time.
   ////////////////////////////////////////////////////////////////////////
   public bool ConfigureChartsBeforeH()
   {
      if( TopViewport == null || Configuration == null ||
          Configuration.Count == 0 )
        return false;

      GlgObject chart_series = TopViewport.GetResourceObject( "ChartSeries" );
      if( chart_series == null )
      {
         AppError( "ChartSeries not found, chart configuration failed.", false );
         NumCharts = 0;
         return false;
      }

      // Set number of charts in the drawing.
      NumCharts = Configuration.Count;
      chart_series.SetDResource( "NumCharts", NumCharts );

      /* Set BufferSize for the series' template before hierarchy setup. This
         setting will be inherited by all series' instances (individual charts)
         when the instances get created during hierarchy setup.
      */
      chart_series.SetDResource( "ChartViewport/Chart/BufferSize", BufferSize );
      
      /* Set number of menu items in the ChartDialog (if any) to match the
         number of charts.
      */
      InitChartMenuBeforeH();

      return true;
   }

   ////////////////////////////////////////////////////////////////////////
   // Create new ChartArray based on the stored Configuration (if any).
   // Must be invoked after hierarchy setup.
   ////////////////////////////////////////////////////////////////////////
   public void ConfigureChartsAfterH()
   {
      if( TopViewport == null || Configuration == null || NumCharts == 0 )
      {
         AppError( "Chart configuration failed.", false );
         ClearConfiguration();
         return;
      }

      // Retrieve ChartSeries object.
      GlgObject chart_series = TopViewport.GetResourceObject( "ChartSeries" );
      if( chart_series == null )
      {
         AppError( "ChartSeries not found. Chart configuration failed.", false );
         ChartArray = null;
         return;
      }

      /* Create new ChartArray and populate it with chart information based 
         on the provided chart configuration.
      */
      ChartArray = new List<ChartInfo>();
      for( int i=0; i<NumCharts; ++i )
      {
         // Retrieve objectID of the individual chart viewport.
         GlgObject chart_vp =
           chart_series.GetResourceObject( "ChartViewport" + i );

         // Create new ChartInfo record and Add it to the ChartArray.
         ChartInfo chart_info = new ChartInfo();

         // Initialize an individual chart.
         chart_info.InitializeChart( Configuration[  i ],
                                     chart_vp, i );

         ChartArray.Add( chart_info );
      }

      // Configure Chart menu in the ChartDialog, if any.
      InitChartMenuAfterH();

      /* Populate SpanSelector option menu with items based on the SpanData 
         array. The menu allows to select a desired time span for the TimeAxis.
         Menu initialization must be done after hierarchy setup.
         
         The demo uses the same SpanData array for both Configuration1 and
         Confgiguration2, but the application may extend the code to supply 
         a different SpanData array for each configuration. 
      */
      InitSpanSelector( SpanData );
      
      // Enable AutoScroll for the charts.
      ChangeAutoScroll( 1 );

      // Disable Y Dragging by default.
      ChangeYDragging( 0 );

      // Set time span of the TimeAxis.
      SetChartSpan( SpanIndex );

      if( PrefillData )
        PrefillChartsWithData();      
   }

   ////////////////////////////////////////////////////////////////////////
   public void PrefillChartsWithData()
   {
      if( NumCharts == 0 )
        return;

      /* Prefill each chart's history buffer with data. The demo prefills
         the buffer with data up to the current time.
      */
      for( int i=0; i<NumCharts; ++i )
        FillChartHistory( ChartArray[ i ] );
   }

   /////////////////////////////////////////////////////////////////////////
   public void InitChartMenuBeforeH()
   {
      if( ChartMenu == null || NumCharts <= 0 )
        return;

      // Set number of menu rows.
      ChartMenu.SetDResource( "NumRows", NumCharts );

      // Adjust number of visible rows.
      ChartMenu.SetDResource( "NumVisibleRows", ChartMenuNumVisRows );
   }

   /////////////////////////////////////////////////////////////////////////
   // Popuplate ChartMenu inside ChartDialog using data from Configuration[]
   // array. This function is invoked after hierarchy setup.
   /////////////////////////////////////////////////////////////////////////
   public void InitChartMenuAfterH()
   {
      if( ChartMenu == null )
        return;

      /* Populate chart menu with labels using Configuration array and set
         the state of each toggle button based on the specified initial 
         visibility.
      */
      for( int i=0; i<NumCharts; ++i )
      {
         GlgObject button = ChartMenu.GetResourceObject( "Button" + i );
         ChartConfigRecord config_record = Configuration[ i ];
         button.SetSResource( "LabelString", config_record.chart_title );
         button.SetDResource( "OnState",
                              config_record.init_visibility ? 1.0 : 0.0 );
      }
   }

   ////////////////////////////////////////////////////////////////////////
   // Show/hide ChartDialog.
   ////////////////////////////////////////////////////////////////////////
   public void ShowChartDialog( bool show )
   {
      if( ChartDialog == null )
        return;

      ChartDialog.SetDResource( "Visibility", show ? 1.0 : 0.0,
                                true /*if changed*/ );
   }

   const int row_height = 30;

   ////////////////////////////////////////////////////////////////////////
   // Set dialog size and position the dialog.
   ////////////////////////////////////////////////////////////////////////
   void SetDialogSizeAndPosition( GlgObject dialog )
   {
      if( dialog == null )
        return;
   
      int height = row_height * ChartMenuNumVisRows + 55;
      int width = 180;

      // Disable dialog positioning by control points.
      dialog.SetGResource( "Point1", 0.0, 0.0, 0.0 );
      dialog.SetGResource( "Point2", 0.0, 0.0, 0.0 );

      // Set dialog initial position.
      dialog.SetDResource( "Screen/XHint", 200.0 );
      dialog.SetDResource( "Screen/YHint", 200.0 );
    
      dialog.SetDResource( "Screen/WidthHint", width );
      dialog.SetDResource( "Screen/HeightHint", height );
   }
   
   ///////////////////////////////////////////////////////////////////////
   // Invoked periodically with time interval = UpdateInterval.
   ///////////////////////////////////////////////////////////////////////
   public void OnTimerUpdate( object sender, System.Timers.ElapsedEventArgs e )
   {
      if( !TimerEnabled )
        return;                 // Prevents race conditions.

      UpdateChart();            // Update the chart with new data.

      timer.Start();            // Restart the timer. 
   }

   ///////////////////////////////////////////////////////////////////////
   // Push new data values to all lines in the chart.
   // Invoked periodically by timer with time interval defined by
   // UpdateInterval.
   ///////////////////////////////////////////////////////////////////////
   public void UpdateChart()
   {
      /* Perform dynamic updates only if the drawing is ready and the
         timer is active.
      */
      if( !Ready )
        return;

      /* Demo: Store current time. It is used to generate a data sample's 
         time stamp in demo mode when data come in packets.
      */
      current_time = GetCurrTime();

      // Update plot lines with new data supplied by the DataFeed object.
      for( int i=0; i<NumCharts; ++i )
      {
         /* Use DataFeed to get new data value. The DataFeed object
            fills the data_point object with value, time_stamp, etc.
         */
         PlotInfo plot_info = ChartArray[ i ].plot_info;

         List<PlotDataPoint> data_array = null;
         if( USE_DATAVAR_NAME || plot_info.tag_index < 0 )
           // Use data source variable name (tag_source). 
           data_array = DataFeed.GetPlotData( plot_info.tag_source );
         else
           // Use data variable index, for example sensor number. 
           data_array = DataFeed.GetPlotData( plot_info.tag_index );

         if( data_array != null )
         {
            PushPlotData( plot_info, data_array );

            // Setup chart hierarchy to prepare it for the time line update.
            ChartArray[ i ].chart.SetupHierarchy();
         }
         else
           AppInfo( "Error getting plot data sample for " +
                    plot_info.tag_source );
      }

      /* Update the cross-hair line to follow the mouse cursor. 
         If the cursor is outside one of the charts or the time axis, 
         the cross-hair line will not be disabled.
      */
      DisplayCrossHairLine( CursorPosition );

      UpdateGlg(); // Refresh display.

      // Demo: Store time of the last update.
      last_time = current_time;
   }

   ///////////////////////////////////////////////////////////////////////
   public void PushPlotData( PlotInfo plot_info,
                             List<PlotDataPoint> data_array )
   {
      if( plot_info == null || data_array == null )
        return;
      
      int num_samples = data_array.Count;
      bool quick_mode = true;
      
      for( int i=0; i<num_samples; ++i )
      {
         PlotDataPoint data_point = data_array[ i ];
         
         if( FAST_DATA_PROCESSING && SUPPLY_TIME_STAMP )
         {
            /* For performance optimization, low level API methods may be used
               to push data into the plot's data buffer. Use quick_mode=true 
               to speed-up the process even further. However, it will 
               require the application to advance the time axis and 
               handle auto-scaling manually.
            */
            PushPlotPointDirect( plot_info, data_point, quick_mode );
         }
         else
           PushPlotPoint( plot_info, data_point );
      }

      // If quick mode is used, advance the time axis explicitly.
      if( quick_mode && FAST_DATA_PROCESSING && SUPPLY_TIME_STAMP )
        TimeAxis.SetDResource( "EndValue",
                               data_array[  num_samples - 1 ].time_stamp );      
   }
   
   ///////////////////////////////////////////////////////////////////////
   // Pushes the data_point's data into the plot.
   ///////////////////////////////////////////////////////////////////////
   public void PushPlotPoint( PlotInfo plot_info, PlotDataPoint data_point )
   {
      // Supply plot value for the chart via ValueEntryPoint.
      plot_info.value_ep.SetDResource( null, data_point.value );

      if( data_point.time_stamp != 0 )
      {
         /* Supply an optional time stamp. If not supplied, the chart will 
            automatically generate a time stamp using current time. 
         */
         plot_info.time_ep.SetDResource( null, data_point.time_stamp );
      }

      if( !data_point.value_valid )
      {
         /* If the data point is not valid, set ValidEntryPoint resource to 
            display holes for invalid data points. If the point is valid,
            it is automatically set to 1. by the chart.
         */
         plot_info.valid_ep.SetDResource( null, 0.0 );
      }
   }

   ///////////////////////////////////////////////////////////////////////
   // Use low level API methods to push data into the plot's data buffer.
   ///////////////////////////////////////////////////////////////////////
   public void PushPlotPointDirect( PlotInfo plot_info,
                                    PlotDataPoint data_point,
                                    bool quick_mode )
   {
      if( plot_info == null || data_point == null )
        return;
      
      GlgObject plot = plot_info.plot;
      
      // Get a datasample from a cache, if available, or create a new one.
      GlgDataSampleNode node = GlgObject.CreateDataSampleNode( plot, false );
      GlgDataSample datasample = node.GetNodeDataSample();
      datasample.value = data_point.value;
      datasample.time = data_point.time_stamp;
      datasample.valid = data_point.value_valid;
      
      /* Display markers for plots that contain markers 
         (PlotType = MARKERS or LINE_AND_MARKERS).
      */
      datasample.marker_vis = 1.0f;
     
      plot.AddDataSampleNode( node, quick_mode );
   }
   
   /////////////////////////////////////////////////////////////////////// 
   // Pre-fill the history buffer of an individual chart with data. 
   /////////////////////////////////////////////////////////////////////// 
   public void FillChartHistory( ChartInfo chart_info )
   {
      if( chart_info == null )
        return;

      /* Fill the amount of data requested by the PREFILL_SPAN, up to the 
         available chart's buffer size. Add an extra second to avoid 
         rounding errors.
      */
      double num_seconds = PREFILL_SPAN + 1;

      /* Calculate maximum number of seconds for prefilling the chart based
         on the chart's BufferSize. Add an extra second to avoid rounding 
         errors.
      */
      double interval = GetSampleInterval();
      double max_num_sec = BufferSize * interval + 1.0;

      if( num_seconds > max_num_sec )
        num_seconds = max_num_sec;
      
      double start_time = current_time - num_seconds;
      double end_time = current_time;   /* Stop at the current time. */

      /* This example uses one plot per chart. The code may be extended 
         to support multiple plots in each chart.
      */
      List<PlotDataPoint> data_array = null;
      if( USE_DATAVAR_NAME || chart_info.plot_info.tag_index < 0 )
        data_array = DataFeed.GetHistPlotData( chart_info.plot_info.tag_source,
                                               start_time, end_time );
      else
        data_array = DataFeed.GetHistPlotData( chart_info.plot_info.tag_index,
                                               start_time, end_time );

      if( data_array == null || data_array.Count == 0 )
      {
         AppInfo( "No historical data for " + chart_info.plot_info.tag_source );
         return;
      }

      /* Fill plot's histrorical data buffer with data from the provided
         data_array. For increased performance, use low level API methods 
         in quick mode to push data into the plot's history buffer to speed up
         prefilling of the chart.
      */
      for( int i=0; i<data_array.Count; ++i )
        PushPlotPointDirect( chart_info.plot_info, data_array[ i ],
                             /*quick mode*/ true );
   }

   ////////////////////////////////////////////////////////////////////////
   // Initialize SpanSelector drop-down menu used to change the time span
   // on the TimeAxis. The menu is populated with items dynamically based
   // on the SpanData array.
   ////////////////////////////////////////////////////////////////////////
   public void InitSpanSelector( SpanInfo[] span_data )
   {
      if( span_data == null )
        return;

      GlgObject menu = Toolbar.GetResourceObject( "SpanSelector" );
      if( menu == null )
      {
         AppInfo( "SpanSelector not found." );
         return;
      }

      // Clear current item list, if any.
      menu.SendMessage( "Handler", "SetItemList", /*empty list*/ null,
                        null, null, null );
      
      // Number of menu items.
      int num_items = span_data.Length;
      
      for( int i=0; i<num_items; ++i )
      {
         string item = span_data[ i ].label;
         menu.SendMessage( "Handler", "AddItem", item,
                           new GlgInteger( (int) GlgAccessType.BOTTOM ), null, null );
      }

      menu.SendMessage( "Handler", "UpdateItemList", null, null, null, null );
   }

   ////////////////////////////////////////////////////////////////////////
   // Allows to reconfigure charts dynamically at run-time.
   ////////////////////////////////////////////////////////////////////////
   public void SetChartConfiguration( List<ChartConfigRecord> new_configuration )
   {
      if( new_configuration == null || SameConfiguration( new_configuration ) )
        return;

      // Disable dynamic updates (if any).
      if( timer != null )
        TimerEnabled = false;

      // Clear current configuration, if any.
      ClearConfiguration();

      // Store new configuration. 
      Configuration = new_configuration;

      /* Set number of charts before hierarchy setup based on the loaded
         configuration.
      */
      if( !ConfigureChartsBeforeH() )
        return;

      // Setup object hierarchy.
      TopViewport.SetupHierarchy();

      // Store current time.
      current_time = GetCurrTime();
      
      // Demo only: Initialize last_time to the current time.
      last_time = current_time;

      // Configure charts after hierarchy setup.
      ConfigureChartsAfterH();

      TopViewport.UpdateGlg();

      // Charts are configured and ready for data updates.
      Ready = true;
      
      // Resume dynamic updates (if the time has been already started).
      if( timer != null )
        TimerEnabled = true;
   }

   ////////////////////////////////////////////////////////////////////////
   // Delete current configuration. For example, Clear current configuration
   // prior to creating new configuration.
   ////////////////////////////////////////////////////////////////////////
   public void ClearConfiguration()
   {
      ChartArray = null;
      NumCharts = 0;
      Configuration = null;
      Ready = false;
      DataFeed.ClearDataFeed();
   }

   ///////////////////////////////////////////////////////////////////////
   // Handle user interaction.
   // Each ChartViewport% in ChartSeries has OwnsInputCB=true, so
   // InputCallback is invoked with the viewport ID of the ChartViewport%
   // where an input event_cs occurred, such as chart zoom or drag event_cs.
   ///////////////////////////////////////////////////////////////////////
   public override void InputCallback( GlgObject viewport,
                                        GlgObject message_obj )
   {
      string
        origin,
        format,
        action,
        subaction;

      origin = message_obj.GetSResource( "Origin" );
      format = message_obj.GetSResource( "Format" );
      action = message_obj.GetSResource( "Action" );
      subaction = message_obj.GetSResource( "SubAction" );

      // Handle window closing.
      if( format.Equals( "Window" ) && action.Equals( "DeleteWindow" ) )
      {
         if( origin.Equals( "ChartDialog" ) )
         {
            // Hide ChartDialog.
            ShowChartDialog( false );
            UpdateGlg();
         }
      }

      // Process button events.
      else if( format.Equals( "Button" ) )
      {
         if( !action.Equals( "Activate" ) &&      /* Not a push button */
             !action.Equals( "ValueChanged" ) )    /* Not a toggle button */
            return;

         // Abort ZoomTo mode, if any.
         AbortZoomTo();

         if( origin.Equals( "ToggleAutoScroll" ) )
         {
            /* Set Chart AutoScroll based on the ToggleAutoScroll 
               toggle button setting.
            */
            ChangeAutoScroll( -1 );
         }
         if( origin.Equals( "ToggleYDragging" ) )
         {
            /* Enable/Disable Y Dragging based on the ToggleYDragging toggle 
               button setting.
            */
            ChangeYDragging( -1 );
         }
         else if( origin.Equals( "ZoomTo" ) )
         {
            /* Start ZoomTo operation. Wait for the mouse click in the
               TraceCallback to activate ZoomTo for the selected chart 
               that received the click. 
            */
            StartZoomToMode = true;
         }
         else if( origin.Equals( "ResetZoom" ) )
         {
            // Set initial time span and reset initial Y ranges.
            SetChartSpan( SpanIndex );
            RestoreInitialYRanges();

            // Disable Y Dragging on zoom reset (1:1 button).
            ChangeYDragging( 0 );
         }
         else if( origin.Equals( "ScrollBack" ) ||
                  origin.Equals( "ScrollForward" ) )
         {
            ChangeAutoScroll( 0 );

            double end_value =
              TimeAxis.GetDResource( "EndValue" ).DoubleValue();

            if( origin.Equals( "ScrollBack" ) )
               end_value -= ScrollIncrement;
            else
               end_value += ScrollIncrement;

            TimeAxis.SetDResource( "EndValue", end_value );
         }
         else if( origin.Equals( "ScrollToRecent" ) )
         {
            // Scroll to show most recent data.
            ScrollToDataEnd( MOST_RECENT, true );
         }
         else if( origin.Equals( "ShowHideCharts" ) )
         {
            /* Display ChartDialog when the user clicked on the
               Configure toolbar button.
            */
            ShowChartDialog( true );
         }

         UpdateGlg();
      }

      // Handle events from the drop-down combobox widget.
      else if( format.Equals( "Option" ) )
      {
         if( !action.Equals( "Select" ) )
           return;

         // Abort ZoomTo mode, if any.
         AbortZoomTo();

         /* Handle events from the SpanSelector menu allowing to select time 
            interval for the X axis.
         */
         if( origin.Equals( "SpanSelector" ) )    /* Span changed. */
         {
            SpanIndex = message_obj.GetDResource( "SelectedIndex" ).IntValue();

            SetChartSpan( SpanIndex );
            RestoreInitialYRanges(); /* Restore in case the chart was zoomed.*/

            /* Scroll to show the recent data to avoid showing an empty chart
               if user scrolls too much into the future or into the past.
               Invoke ScrollToDataEnd() even if AutoScroll is On to scroll 
               ahead by a few extra seconds to show a few next updates without
               scrolling the chart.
            */
            GlgMinMax min_max =
              ChartArray[ 0 ].chart.GetChartDataExtent( null, /*x extent*/ true, /*query all samples*/ false );

            if( min_max != null )
            {
               double first_time_stamp = min_max.min;
               double last_time_stamp = min_max.max;
               double displayed_time_end =
                 TimeAxis.GetDResource( "EndValue" ).DoubleValue();

               if( AutoScrollState != 0 )
                 ScrollToDataEnd( MOST_RECENT, true );
               else if( displayed_time_end >
                        last_time_stamp + GetExtraSeconds() )
                 ScrollToDataEnd( MOST_RECENT, true );

               else if( displayed_time_end - TimeSpan <= first_time_stamp )
                 ScrollToDataEnd( LEAST_RECENT, true );

               viewport.UpdateGlg();
            }
         }

      }

      // Handle events from the GlgMenu.
      else if( format.Equals( "Menu" ) )
      {
         if( origin.Equals( "ChartMenu" ) )
         {
            // Handle events from the ChartMenu inside ChartDialog.
            int button_index =
              message_obj.GetDResource( "SelectedIndex" ).IntValue();
            GlgObject menu = message_obj.GetResourceObject( "Object" );
            ProcessChartMenuSelection( menu, button_index );
         }

         UpdateGlg();
      }

      // Handle custom MouseClick events.
      else if( format.Equals( "CustomEvent" ) )
      {
         string event_label = message_obj.GetSResource( "EventLabel" );
         if( event_label == null )
           return;

         /* Hide ChartDialog when the user clicked on the Close button 
            inside the dialog (Close button has Custom MouseEvent with 
            EventLabel="CloseChartDialog").
         */
         if( event_label.Equals( "CloseChartDialog" ) )
           ShowChartDialog( false );

         UpdateGlg();
      }

      else if( format.Equals( "Chart" ) &&
               action.Equals( "CrossHairUpdate" ) )
      {
         /* To avoid slowing down real-time chart updates, invoke Update() 
            to redraw cross-hair only if the chart is not updated fast 
            enough by the timer.
         */
         if( UpdateInterval > 100 )
           UpdateGlg();
      }

      else if( format.Equals( "Zoom" ) && action.Equals( "Zoom" ) ) // Zoom events
      {
         if( subaction.Equals( "ZoomRectangle" ) )
         {
            // Store AutoSCroll state to restore it if ZoomTo is aborted.
            StoredScrollState = AutoScrollState;
            
            // Stop scrolling when ZoomTo action is started.
            ChangeAutoScroll( 0 );
         }
         else if( subaction.Equals( "End" ) )
         {
            /* No additional actions on finishing ZoomTo. The Value axis 
               scrollbar appears automatically if needed: 
               it is set to GLG_PAN_Y_AUTO for a horizontal chart
               and GLG_PAN_X_AUTO for a vertical chart.
               Don't resume scrolling: it'll scroll too fast since we zoomed 
               in. Keep it still to allow inspecting zoomed data.
            */
         }
         else if( subaction.Equals( "Abort" ) )
         {
            // Resume scrolling if it was on.
            ChangeAutoScroll( StoredScrollState );
         }
         
         UpdateGlg();
      }

      else if( format.Equals( "Pan" ) && action.Equals( "Pan" ) )  // Pan events
      {
         // This code may be used to perform custom action when dragging the 
         // chart's data with the mouse. 
         if( subaction.Equals( "Start" ) )   // Chart dragging Start
         {
         }
         else if( subaction.Equals( "Drag" ) )    // Dragging
         {
            /* Refresh display when the chart is dragged to ensure the cross-hair
               line and values in annotations coinside with the cursor position.  
            */
            UpdateGlg();
         }
         else if( subaction.Equals( "ValueChanged" ) )   // Scrollbars
         {
         }
         /* Dragging ended or aborted. */
         else if( subaction.Equals( "End" ) || subaction.Equals( "Abort" ) )
         {
         }
      }
   }

   ///////////////////////////////////////////////////////////////////////
   // Used to obtain coordinates of the mouse click, as well as handle
   // native low level events as needed.
   ///////////////////////////////////////////////////////////////////////
   public override void TraceCallback( GlgObject viewport,
                                       GlgTraceData trace_info )
   {
      if( !Ready )
        return;

      // Obtain the viewport where the event_cs occurred.
      GlgObject event_vp = trace_info.viewport;
      string vp_name = event_vp.GetSResource( "Name" );

      GlgEventType event_type = trace_info.glg_event.GetEventID();
      double x = 0, y = 0;
      switch( event_type )
      {
       case GlgEventType.MOUSE_PRESSED:
       case GlgEventType.MOUSE_MOVED:
         // Retrieve mouse coordinates.
         x = (double) ((MouseEventArgs)trace_info.glg_event.event_args).X;
         y = (double) ((MouseEventArgs)trace_info.glg_event.event_args).Y;
         
         /* COORD_MAPPING_ADJ is added to the cursor coordinates for precise
            pixel mapping.
         */
         x += GlgObject.COORD_MAPPING_ADJ;
         y += GlgObject.COORD_MAPPING_ADJ;
         break;
         
       default:
         break;
      }

      switch( event_type )
      {
       case GlgEventType.MOUSE_PRESSED: 
         /* Handle only events that occur in one of the chart viewports
            with the name beginning with "ChartViewport".
         */
         if( !vp_name.StartsWith(  "ChartViewport" , StringComparison.Ordinal ) )
           return;
         
         if( StartZoomToMode )
         {
            event_vp.SetZoom( null, 't', 0.0 );
            StartZoomToMode = false;
            return;
         }
         
         /* If ZoomTo mode is in progress for any of the charts,
            do nothing else.
         */
         GlgObject zoom_vp = ZoomToMode();
         if( zoom_vp != null )
           return; // ZoomTo or dragging mode in progress.
         
         /* Start dragging with the mouse when the user clicked in one of the
            chart areas. If Y dragging is enabled, dragging is activated 
            in both X and Y direction ('s'). Otherwise, dragging is activated 
            only in X direction ('>').
         */
         char drag_type = ( EnableYDragging == 1 ? 's' : '>' ); 
         event_vp.SetZoom( null, drag_type, 0.0 );
               
         // Disable AutoScroll not to interfere with dragging.
         ChangeAutoScroll( 0 );
         UpdateGlg();
         break;
         
       case GlgEventType.MOUSE_MOVED: 
         /* Handle only events that occur in one of the chart viewports 
            with the name beginning with "ChartViewport", or in the 
            top level $Widget viewport that contains TimeAxis.
         */
         if( !vp_name.StartsWith(  "ChartViewport" , StringComparison.Ordinal ) &&
             !vp_name.StartsWith(  "$Widget" , StringComparison.Ordinal ) )
         {
            CursorPosition = null;
            return;
         }
         
         // Store cursor position.
         CursorPosition = new GlgPoint( x, y, 0.0 );
         
         /* If the mouse moves along the Time axis (which is a child of 
            $Widget), convert cursor position relatively to one of the 
            chart viewports, since we later use the chart (not TimeAxis)
            to obtain a time stamp at cursor. Since we take into consideration
            only horizontal position of the cursor, and all charts are aligned
            vertically and have the same width, we can convert the coordinates
            relatively to the first chart viewport. The cursor X coordinate in
            the $Widget viewport differs from X coordinate in the chart 
            viewports by the border width of the chart viewport, therefore 
            the cursor position needs to be converted to the chart viewport.
         */
         if( vp_name.StartsWith(  "$Widget" , StringComparison.Ordinal ) )
           GlgObject.TranslatePointOrigin( event_vp,
                                           ChartArray[ 0 ].chart_vp,
                                           CursorPosition );
         
         /* Display vertical time line at cursor position if there is no
            zooming or dragging mode in progress.
         */
         if( ZoomToMode() == null ) 
           DisplayCrossHairLine( CursorPosition );
         break;
         
       case GlgEventType.MOUSE_EXITED:
         CursorPosition = null;
         DisplayCrossHairLine( CursorPosition ); // Erase crosshair.
         break;

       default:
         return;
      }
   }
   
   ///////////////////////////////////////////////////////////////////////
   // Process item selection in the ChartMenu located in the ChartDialog.
   // Show/Hide individual charts based on the state of the selected menu
   // item.
   ///////////////////////////////////////////////////////////////////////
   public void ProcessChartMenuSelection( GlgObject chart_menu, int index )
   {
      if( chart_menu == null || index < 0 || index >= NumCharts )
        return;

      GlgObject button = chart_menu.GetResourceObject( "Button" + index );
      int state = button.GetDResource( "OnState" ).IntValue();

      // Show/Hide individual chart based on the menu item selection.
      ChartArray[ index ].ShowChart( state == 0 ? false : true );
   }

   ///////////////////////////////////////////////////////////////////////
   // Scroll to the end of the data history buffer.
   // All charts have XAxis/Span and XAxis/EndValue constrained, so the
   // charts scroll together. TimeAxis/Span and TimeAxis/EndValue are also
   // constrained to the charts' XAxis/Span and XAxis/EndValue repspectvely.
   ///////////////////////////////////////////////////////////////////////
   public void ScrollToDataEnd( int data_end, bool show_extra_sec )
   {
      if( data_end == DONT_CHANGE )
        return;

      // Use the first chart to obtain data extent.
      GlgMinMax min_max =
        ChartArray[ 0 ].chart.GetChartDataExtent( null, /*x extent*/ true, /*query all samples*/ false );
      if( min_max == null )
        return;

      double extra_sec;
      if( show_extra_sec )
        extra_sec = GetExtraSeconds();
      else
        extra_sec = 0.0;

      double end_value;
      if( data_end == MOST_RECENT )
        end_value = min_max.max + extra_sec;
      else   /* LEAST_RECENT */
        end_value = min_max.min - extra_sec + TimeSpan ;
      
      TimeAxis.SetDResource( "EndValue", end_value );
   }

   ///////////////////////////////////////////////////////////////////////
   // Change chart's AutoScroll mode.
   ///////////////////////////////////////////////////////////////////////
   public void ChangeAutoScroll( int new_value )
   {
      if( new_value == -1 )  // Use the state of the ToggleAutoScroll button.
      {
         AutoScrollState =
           Toolbar.GetDResource( "ToggleAutoScroll/OnState" ).IntValue();
      }
      else    // Set to the supplied value. 
      {
         AutoScrollState = new_value;
         Toolbar.SetDResource( "ToggleAutoScroll/OnState",
                               (double) AutoScrollState );
      }

      /* Set chart's auto-scroll. AutoScroll property is constrained for
         all charts, so we can use the first chart.
      */
      ChartArray[ 0 ].chart.SetDResource( "AutoScroll",
                                                     (double) AutoScrollState );
   }

   ///////////////////////////////////////////////////////////////////////
   // Change Y Dragging mode.
   ///////////////////////////////////////////////////////////////////////
   public void ChangeYDragging( int new_value )
   {
      if( new_value == -1 ) // Use the state of the ToggleYDragging button.
      {
        EnableYDragging =
          Toolbar.GetDResource( "ToggleYDragging/OnState" ).IntValue();
      }
      else    // Set to the supplied value. 
      {
         EnableYDragging = new_value;
         Toolbar.SetDResource( "ToggleYDragging/OnState",
                               (double) EnableYDragging );
      }
   }

   ///////////////////////////////////////////////////////////////////////
   // Changes the time span shown in the TimeAxis. span_index is the 
   // current SelectedIndex of the SpanSelector combobox widget in the 
   // chart's toolbar.
   ///////////////////////////////////////////////////////////////////////
   public void SetChartSpan( int span_index )
   {
      if( span_index > SpanData.Length )
      {
         AppError( "Ivalid span_index.", false );
         return;
      }

      SpanInfo span_info = SpanData[ span_index ];

      /* Update the SpanSeolector menu in the drawing with the initial value
         if different.
      */
      Toolbar.SetDResource( "SpanSelector/SelectedIndex", span_index, true );

      /* Set intervals before SetZoom() below to avoid redrawing huge number
         of labels.
      */
      TimeAxis.SetDResource( "MajorInterval", span_info.major_interval );
      TimeAxis.SetDResource( "MinorInterval", span_info.minor_interval );

      /* Set Time axis span, which controls how much data is displayed 
         in the chart. 
       */
      TimeSpan = span_info.span;
      TimeAxis.SetDResource( "Span", (double) TimeSpan );

      // Calculate scroll increment in seconds based on the TimeSpan.
      ScrollIncrement = TimeSpan / 30.0;

      /* Turn on data filtering for large spans. 
         FilterType and FilterPrecision attributes are Global in the 
         ChartSeries and therefore are constrained for all chart plots, 
         so we can set these resources only for the first chart.
      */
      GlgObject plot = ChartArray[ 0 ].plot_info.plot;
      if( span_info.span >= ONE_MINUTE )
      {
         /* Agregate multiple data samples to minimize a number of 
            data points drawn per each FilterPrecision interval. 
            Show only one set of MIN/MAX values per each pixel interval. 
         */
         plot.SetDResource( "FilterType",
                            (double) GlgChartFilterType.MIN_MAX_FILTER );
         plot.SetDResource( "FilterPrecision", 2.0 );
      }
      else
        plot.SetDResource( "FilterType",
                            (double) GlgChartFilterType.NULL_FILTER );

      /* Set TimeFormat for the TimeAxis if supplied.
         Otherwise, use TimeFormat as defined in the drawing. 
      */
      if( span_info.time_format != null )
        TimeAxis.SetSResource( "TimeFormat", span_info.time_format );

      /* Set TooltipFormat for each chart if supplied. Otherwise, 
         use TooltipFormat as defined in the drawing. 
         TooltipFormat is constrained for all charts, so we can use 
         the first chart to set the attribute.
      */
      if( span_info.tooltip_format != null )
        ChartArray[ 0 ].chart.SetSResource( "TooltipFormat",
                                             span_info.tooltip_format );
   }

   ///////////////////////////////////////////////////////////////////////
   // Restore Y axis range to the initial Low/High values.
   ///////////////////////////////////////////////////////////////////////
   public void RestoreInitialYRanges()
   {
      if( NumCharts == 0 )
        return;

      for( int i=0; i<NumCharts; ++i )
      {
         GlgObject chart = ChartArray[ i ].chart;
         chart.SetDResource( "YAxis/Low", ChartArray[ i ].low );
         chart.SetDResource( "YAxis/High", ChartArray[ i ].high );
      }
   }

   ///////////////////////////////////////////////////////////////////////
   // Returns the chart viewport which is ZoomToMode, if any.
   // ZoomToMode is activated on Dragging and ZoomTo operations.
   ///////////////////////////////////////////////////////////////////////
   public GlgObject ZoomToMode()
   {
      for( int i=0; i<NumCharts; ++i )
      {
         int zoom_mode =
           ChartArray[ i ].chart_vp.GetDResource( "ZoomToMode" ).IntValue();

         if( zoom_mode != 0 )
           return ChartArray[ i ].chart_vp;
      }

      return null;
   }

   ///////////////////////////////////////////////////////////////////////
   // Abort ZoomTo mode.
   ///////////////////////////////////////////////////////////////////////
   public void AbortZoomTo()
   {
      GlgObject zoom_viewport = ZoomToMode();
      if( zoom_viewport == null )
        return;

      // Abort zoom mode in progress.
      zoom_viewport.SetZoom( null, 'e', 0.0 );
      UpdateGlg();
   }

   ////////////////////////////////////////////////////////////////////////
   // Display a vertical cross-hair line at cursor position, as well as
   // display annotations for each chart.
   ////////////////////////////////////////////////////////////////////////
   public void DisplayCrossHairLine( GlgPoint cursor_pos )
   {
      if( !Ready )
        return;
      
      if( cursor_pos == null )
      {
         DisableCrossHairAndAnnotations();
         return;
      }

      /* Obtain time value at cursor position, taking into account only 
         X direction. Use the first chart, since all charts have a 
         common Time axis.
      */
      GlgDouble time_stamp_obj =
        ChartArray[ 0 ].chart.PositionToValue( null, cursor_pos.x,
                                                 cursor_pos.y,
                                                 true /*X direction*/,
                                                 false /*Y direction*/ );

      /* Disable the cross-hair line and all annotations if the cursor 
         is outside the chart area in horizontal direction
         (time_stamp_obj=null).
      */
      if( time_stamp_obj == null )
      {
         DisableCrossHairAndAnnotations();
         return;
      }

      double time_stamp = time_stamp_obj.DoubleValue();
      
      /* Cursor is either inside one of the charts or inside the time axis: 
         Enable the cross-hair lines and position them using the new 
         time stamp, so that the cross-hair follows the mouse cursor.
      */
      UpdateCrossHair( true, time_stamp );

      /* In each chart, highlight a datasample nearest to the time stamp
         and display its value.
      */
      DisplayAnnotations( time_stamp );

      // Refresh display.
      UpdateGlg();
   }

   //////////////////////////////////////////////////////////////////////////
   // Disable/enable cross hair line. Cross hair line parameters are
   // constrained for all charts, so positioning the cross hair line in the
   // first chart will position cross hair lines in all charts.
   //////////////////////////////////////////////////////////////////////////
   void UpdateCrossHair( bool enable, double time_stamp )
   {
      if( ChartArray == null )
        return;
      
      GlgObject cross_hair = ChartArray[ 0 ].cross_hair_line;
      if( cross_hair == null )
        return;

      // Enable/disable cross hair based on the enable flag.
      cross_hair.SetDResource( "Enabled", enable ? 1.0 : 0.0 );

      // Update cross hair position. 
      if( enable )
        cross_hair.SetDResource( "Time", time_stamp );
   }

   ///////////////////////////////////////////////////////////////////////////
   // In each chart, find a datasample nearest to the time stamp, highlight it
   // using a marker annotaion, and display its value using a label annotation.
   ///////////////////////////////////////////////////////////////////////////
   void DisplayAnnotations( double time_stamp )
   {
      for( int i=0; i<NumCharts; ++i )
      {
         GlgPoint plot_point = 
           GetPlotValueAtTimeStamp( ChartArray[ i ], time_stamp );
         if( plot_point == null )
           // Data sample not found, disable annotations for this chart.
           UpdateChartAnnotations( ChartArray[ i ], false /*disable*/,
                                    null, -1 );
         else
           // Found data sample, enable and update chart annotations.
           UpdateChartAnnotations( ChartArray[ i ], true /*enable*/,
                                    plot_point, time_stamp );
      }
   }

   ///////////////////////////////////////////////////////////////////////////
   // Finds a chart datasample nearest to the time stamp and returns its
   // X/Y values. Returns null if not found. 
   ///////////////////////////////////////////////////////////////////////////
   GlgPoint GetPlotValueAtTimeStamp( ChartInfo chart_info, double time_stamp )
   {
      if( chart_info == null )
        return null;

      GlgObject chart = chart_info.chart;
      GlgObject plot = chart_info.plot_info.plot;
      if( plot == null )
        return null;

      /* Find plot's datasample nearest to specified time stamp within
         the dx search interval.  
      */
      double dx = 5.0; // 5 sec search interval for X axis
      double dy = 0;   // Not needed, since we ignore Y direction in the search.
      GlgObject selection =
          chart.CreateChartSelection( plot, time_stamp, 0, dx, dy,
                          false /* use time/value instead of screen coord */,
                          false /* exclude invalid points */,
                          true /* nearest in X direction */ );

      if( selection == null )
        return null; // No valid data sample found.

      // Query X/Y values of the selected data sample.
      double x_value = selection.GetDResource( "SampleX" ).DoubleValue();
      double y_value = selection.GetDResource( "SampleY" ).DoubleValue();

      return new GlgPoint( x_value, y_value, 0.0 );
   }

   ///////////////////////////////////////////////////////////////////////////
   // Update parameters of the chart annotations.
   ///////////////////////////////////////////////////////////////////////////
   void UpdateChartAnnotations( ChartInfo chart_info, bool enable,
                                GlgPoint plot_point, double pos_x )
   {
      if( chart_info == null )
        return;

      // Update LabelAnnotation.
      GlgObject label_annotation = chart_info.label_annotation;
      if( label_annotation != null )
      {
         label_annotation.SetDResource( "Enabled", enable ? 1.0 : 0.0 );

         if( enable )
         {
            label_annotation.SetDResource( "Value", plot_point.y );
            label_annotation.SetDResource( "Time", plot_point.x );
            label_annotation.SetDResource( "PositionX", pos_x );
         }
      }

      // Update MarkerAnnotation.
      GlgObject marker_annotation = chart_info.marker_annotation;
      if( marker_annotation != null )
      {
         marker_annotation.SetDResource( "Enabled", enable ? 1.0 : 0.0 );

         if( enable )
         {
            marker_annotation.SetDResource( "Value", plot_point.y );
            marker_annotation.SetDResource( "Time", plot_point.x );
         }
      }
   }

   ///////////////////////////////////////////////////////////////////////////
   // Disable cross-hair line and annotations for all charts.
   ///////////////////////////////////////////////////////////////////////////
   void DisableCrossHairAndAnnotations()
   {
      UpdateCrossHair( false, -1 ); // Disable cross hair.

      // Disable annotations for all charts.
      DisableAllAnnotations();
   }

   ///////////////////////////////////////////////////////////////////////////
   // Disable annotations for all charts.
   ///////////////////////////////////////////////////////////////////////////
   void DisableAllAnnotations()
   {
      // Disable all annotations.
      for( int i=0; i<NumCharts; ++i )
        UpdateChartAnnotations( ChartArray[ i ], false /*disable*/,
                                 null, -1 );
   }

   ///////////////////////////////////////////////////////////////////////////
   // Determines a good number of extra seconds to be added at the end in the
   // real-time mode to show a few next updates without scrolling the chart.
   ///////////////////////////////////////////////////////////////////////////
   public double GetExtraSeconds()
   {
      double extra_sec, max_extra_sec;

      extra_sec = TimeSpan * 0.1;
      max_extra_sec = ( TimeSpan > ONE_HOUR ? 5.0 : 3.0 );

      if( extra_sec > max_extra_sec )
        extra_sec = max_extra_sec;

      return extra_sec;
   }

   //////////////////////////////////////////////////////////////////////////
   // Returns data sample querying interval (in sec.).
   //////////////////////////////////////////////////////////////////////////
   public double GetSampleInterval()
   {
      /* Use sata sampling interval (in seconds) corresponding to the specified
         UpdateInterval. The Update interval is defined in millisec.
         The application may specify data sampling interval as needed.
      */
      double interval = UpdateInterval / 1000.0;
     
      return interval; 
   }
      
   //////////////////////////////////////////////////////////////////////////
   // Return exact time including fractions of seconds.
   //////////////////////////////////////////////////////////////////////////
   public static double GetCurrTime()
   {
      DateTime time_now = DateTime.UtcNow;
      TimeSpan time_span = time_now - Epoch_time;

      return time_span.TotalSeconds;
   }

   //////////////////////////////////////////////////////////////////////////
   // Utility function to validate the string. Returns true if the string
   // is undefined (invalid).
   //////////////////////////////////////////////////////////////////////////
   public static bool IsUndefined( string str )
   {
      if( str == null || str.Equals( "" ) || str.Equals( "unset" ) ||
          str.Equals( "$unnamed" ) )
        return true;

      return false;
   }

   //////////////////////////////////////////////////////////////////////////
   public bool SameConfiguration( List<ChartConfigRecord> new_configuration )
   {
      if( Configuration != null && Configuration == new_configuration )
      {
         AppLog( "Same configuration: new configuration matches currently loaded configuration." );
         return true;
      }

      return false;
   }

   //////////////////////////////////////////////////////////////////////////
   public class SpanInfo
   {
      public string label;
      public int span;                    // time span in seconds.
      public double major_interval;       // X axis major interval.
      public double minor_interval;       // X axis minor interval.
      public string time_format;          // X axis time format.
      public string tooltip_format;       // Plot tooltip format.

      public SpanInfo( string label, int time_span,
                       double major_interval, double minor_interval,
                       string time_format, string tooltip_format )
      {
         this.label = label;
         this.span = time_span;
         this.major_interval = major_interval;
         this.minor_interval = minor_interval;
         this.time_format = time_format;
         this.tooltip_format = tooltip_format;
      }
   }

   /////////////////////////////////////////////////////////////////////// 
   public static void AppError( string error_str, bool quit )
   {
      MessageBox.Show(  error_str , "GLG Demo Error", MessageBoxButtons.OK, MessageBoxIcon.Error );

      if( quit )
        Application.Exit();
   }
   
   /////////////////////////////////////////////////////////////////////// 
   public static void AppInfo( string info_str )
   {
      MessageBox.Show(  info_str , "GLG Demo", MessageBoxButtons.OK, MessageBoxIcon.Information );
   }

   /////////////////////////////////////////////////////////////////////// 
   public static void AppLog( string log_str )
   {
      GlgObject.Error( GlgErrorType.LOGGING,  log_str , null );
   }
}
